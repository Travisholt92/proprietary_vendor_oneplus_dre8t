// @file sns_sar.proto
//
// Defines standard message types for the SAR
//
// Copyright (c) 2017 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
syntax = "proto2";
import "nanopb.proto";
import "sns_std_sensor.proto";
import "sns_physical_sensor_test.proto";

// Attribute requirements:
// The SAR Sensor publishes:
// 1. SNS_STD_SENSOR_ATTRID_TYPE attribute value as "sar".
//    Each SAR sensor (example individual capacitive button) shall be published
//    as an independent sensor with a unique Sensor UID.
// 2. SNS_STD_SENSOR_ATTRID_RESOLUTIONS attribute is not applicable since this
//    is an event sensor.
// 3. SNS_STD_SENSOR_ATTRID_RANGES attribute values in cm unit (proximity distance).
// 4. See sns_std_sensor.proto for other attributes.

// Handling stream requests:
// 1. The SAR sensor can supports both streaming and on-change
//    modes and the operating mode is configured in the Registry.
// 2. The SAR sensor handles the sns_std_sensor_config
//    request for all stream enable/update requests.
// 3. The SAR sensor operates in on-change mode and reports
//    samples only for object (typically human) NEAR/FAR transitions.
//    Since it is an on-change sensor, the sar sensor publishes an initial data event
//    event for each new client request.

enum sns_sar_msgid
{
  option (nanopb_enumopt).long_names = false;

  SNS_SAR_MSGID_SNS_SAR_DATA = 767;
  SNS_SAR_MSGID_SNS_SAR_EVENT  = 769;
  SNS_SAR_SENSOR_MSGID_SAR_DEBUG_EVENT = 799;
}


// Configuration Message
// Used to either request for a certain configuration of the Sim Sensor or
// alter an already existing configuration of the Simulation Sensor
// Uses sns_std_sensor_config defined in sns_std_sensor.proto
// The message field definitions are as follows:
// 1) float sample_rate
//      containing the required sample rate of the Sim sensor in hertz

// Data Message
// Output data event generated by the sar sensor.
message sns_sar_data
{
  // sar Vector along axis x,y,z in m/s2
  repeated float sar = 1 [(nanopb).max_count = 3];

  // Accuracy of the data
  required sns_std_sensor_sample_status accuracy = 2;
}
